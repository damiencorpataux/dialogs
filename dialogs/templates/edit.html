{% extends "html" %}

{% block content %}

<style>
@media (max-width: 992px) {
    #script_header_title {
        max-height: 3rlh;
        overflow: scroll;
    }
}
</style>
<div id="script_header_title" class="mb-3 mb-lg-4">
    <h2 class="d-inline">
        <i class="text-secondary pe-auto me-2" data-feather="film"></i>
        {{ script.name }}
    </h2>
    <span class="small text-secondary ms-3">
        &mdash;&nbsp;<strong>Metadata:</strong> {{ script.__dict__ }}
    </span>
</div>
<div class="d-flex flex-column flex-lg-row gap-1 gap-lg-5">
    <div class="col-lg-4 text-center">
        <video id="player" class="mw-100" controls>
            <source src={{ url_for('api_script_video', script_id=script.name) }} type="video/mp4">
            Your browser does not support the video tag.
        </video>
    </div>
    <div class="flex-grow-1">
        <div class="d-flex gap-2 align-items-baseline">
            <h3>Transcript</h3>
            <div class="small" title="Current time">
                <i class="text-secondary" width="16" data-feather="clock"></i>
                <span id="time_current">0</span> s.
            </div>
            <div class="ms-auto text-muted small" title="Total video time">
                <i class="text-secondary" width="16" data-feather="video"></i>
                <span id="time_total">?</span> s.
            </div>
        </div>
        <style>
            #transcript_timeline {
                position: relative;
                height: 20px;
                width: 100%;
                user-select: none;  /* prevent selecting text while dragging */
            };
        </style>
        <div id="transcript_timeline" class="mb-2 mb-lg-4"></div>
        <div id="transcript_table"></div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', init);

    // Reference UI DOM elements
    const ui = {};
    ui.segments_by_id = null;  // set in cache_transcript()
    ui.transcript_table = document.getElementById('transcript_table');
    ui.segments_dom_table = null;  // set in display_table()
    ui.transcript_timeline = document.getElementById('transcript_timeline');
    ui.segments_dom_timeline = null;  // set in display_timeline()
    ui.transcript_timeline_cursor = null;  // set in display_timeline()
    ui.transcript_timeline_totalduration = null;  // set in display_timeline()
    ui.player = document.getElementById('player');
    ui.player_time_dom = document.getElementById('time_current');
    ui.player_time_total_dom = document.getElementById('time_total');

    // Initialize UX
    function init() {
        get_transcript().then(transcript => {
            display_transcript(transcript);
        });
        // Handle dynamic table height
        document.addEventListener('DOMContentLoaded', adjustTableHeight);
        window.addEventListener('resize', adjustTableHeight);
        setup_player_sync();
        setup_keyboard_shortcuts();
    }
    ui.player.addEventListener('loadeddata', e => {
        ui.player_time_total_dom.innerText = format_time(ui.player.duration)
    });

    // To be called everytime transcript changes
    function cache_transcript(transcript) {
        ui.segments_by_id = {};
        for (const segment of transcript) {
            ui.segments_by_id[segment.id] = segment;
        }
        ui.segments_sorted = Object.values(ui.segments_by_id).sort((a, b) => a.start - b.start);  // array of segments sorted by start time
    }

    // Fetch transcript from server
    async function get_transcript() {
        const script_url = "{{ url_for('api_script_transcript', script_id=script.name) }}";
        const response = await fetch(script_url);
        const transcript = await response.json();
        cache_transcript(transcript);
        return transcript;
    }

    // Post transcript on server
    async function post_transcript(new_transcript) {
        const script_url = "{{ url_for('api_script_transcript_post', script_id=script.name) }}";
        const response = await fetch(script_url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(new_transcript)
        });
        const transcript = await response.json();
        cache_transcript(transcript);
        return transcript;
    }

    // User function to keep up-to-date the transcript table and timeline
    function display_transcript(transcript) {
        display_table(transcript);
        display_timeline(transcript); // Also refresh the timeline
    }

    // Populate #transcript_table with a table containing the given transcript
    function display_table(transcript) {
        let html = `
            <table class="table table-stripped table-hover mb-0">
                <thead>
                    <tr>
                        <th _style="position:sticky;top:0">id</th>
                        <th _style="position:sticky;top:0">Start</th>
                        <th _style="position:sticky;top:0">End</th>
                        <th _style="position:sticky;top:0">Text</th>
                    </tr>
                </thead>
            `;
        for (const segment of transcript) {
            html += `
                <tr data-id="${segment.id}" title="Double-click to edit">
                    <td data-type="id" class="text-secondary">${segment.id}</td>
                    <td data-type="start">${format_time(segment.start)}</td>
                    <td data-type="end">${format_time(segment.end)}</td>
                    <td data-type="text">${segment.text}</td>
                </tr>`;
        }
        html += '</table>';
        ui.transcript_table.innerHTML = html;

        for (const tr of document.querySelectorAll('#transcript_table tr[data-id]')) {
            tr.style.cursor = 'pointer';
            tr.addEventListener('click', e => {
                if (!tr.hasAttribute('contenteditable') || 'false' == tr.getAttribute('contenteditable')) {
                    const segment = ui.segments_by_id[tr.getAttribute('data-id')];
                    ui.player.currentTime = segment.start;
                }
            });
        }
        // Store DOM elements for UX logic
        ui.segments_dom_table = document.querySelectorAll('#transcript_table tbody tr');
        // Setup UX logic
        adjustTableHeight();
        setup_editing();
    }

    // Display timeline
    function display_timeline(transcript) {
        ui.transcript_timeline.innerHTML = ''; // Clear any existing content

        const totalDuration = transcript[transcript.length - 1].end;
        ui.transcript_timeline_totalduration = totalDuration;  // Store total duration globally

        transcript.forEach(segment => {
            const segmentDiv = document.createElement('div');
            segmentDiv.className = 'segment';
            segmentDiv.dataset.id = segment.id;  // Add segment ID for reference
            segmentDiv.style.position = 'absolute';  // TODO: togglable between absolute and relative (expand)
            segmentDiv.style.backgroundColor = 'var(--bs-secondary-color)';
            segmentDiv.style.height = '20px';
            segmentDiv.style.borderRight = '1px dotted black';
            segmentDiv.style.left = (segment.start / totalDuration * 100) + '%';
            segmentDiv.style.width = ((segment.end - segment.start) / totalDuration * 100) + '%';
            segmentDiv.style.color = 'black';
            segmentDiv.style.fontSize = '14px';
            segmentDiv.style.paddingLeft = '3px';
            segmentDiv.innerHTML = `<strong>${segment.id}</strong>`;
            segmentDiv.title = `Segment ${segment.id}\nðŸ•“ ${format_time(segment.start)} âžœ ${format_time(segment.end)} s.\n\n${segment.text}\n `;
            segmentDiv.style.cursor = 'pointer';
            transcript_timeline.appendChild(segmentDiv);
            // Handle click on segment to set player currentTime (desktop & mobile)
            segmentDiv.addEventListener('click', e => ui.player.currentTime = segment.start);
            segmentDiv.addEventListener('touchstart', e => ui.player.currentTime = segment.start);
        });
        // Add the cursor line to the timeline
        const cursorLine = document.createElement('div');
        cursorLine.id = 'cursor_line';
        cursorLine.style.position = 'absolute';
        cursorLine.style.backgroundColor = 'red';
        cursorLine.style.width = '2px';
        cursorLine.style.height = '200%';
        cursorLine.style.top = '-50%';
        cursorLine.style.left = '0';
        transcript_timeline.appendChild(cursorLine);
        // Store DOM elements for UX logic
        ui.transcript_timeline_cursor = document.getElementById('cursor_line');
        ui.segments_dom_timeline = document.querySelectorAll('#transcript_timeline .segment');
        // Setup UX logic
        setup_timeline_cursor_drag();
    }

    function format_time(seconds) {
        return seconds.toFixed(2);
        // return parseFloat(seconds.toFixed(2));
    }

    // Sync player time with table/timeline display
    function setup_player_sync() {
        // Sync segments highlighting with player time
        ui.player.addEventListener('timeupdate', function() {
            ui.player_time_dom.innerText = format_time(this.currentTime);

            ui.segments_dom_table.forEach(row => {
                const segmentId = row.getAttribute('data-id');
                const segment = ui.segments_by_id[segmentId];

                if (segment && this.currentTime >= segment.start && this.currentTime < segment.end) {
                    if (!row.classList.contains('table-primary')) {
                        row.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
                    }
                    row.classList.add('table-primary');
                } else {
                    row.classList.remove('table-primary');
                }
            });

            ui.segments_dom_timeline.forEach(div => {
                const segmentId = div.dataset.id;
                const segment = ui.segments_by_id[segmentId];

                if (segment && this.currentTime >= segment.start && this.currentTime < segment.end) {
                    div.style.backgroundColor = 'var(--bs-info)';
                } else {
                    div.style.backgroundColor = 'var(--bs-secondary-color)';
                }
            });

            // Update the position of the cursor line
            const totalDuration = ui.transcript_timeline_totalduration;
            const currentTimePercent = (ui.player.currentTime / totalDuration) * 100;
            ui.transcript_timeline_cursor.style.left = currentTimePercent + '%';
        });
    }

    // Setup segments edition handling
    function setup_editing() {
        // Generate a valid transcript object from DOM table contents
        function transcript_from_table() {
            transcript = [];
            for (const row of ui.segments_dom_table) {
                transcript.push({
                    id: parseFloat(row.querySelector('[data-type=id]').innerText),
                    start: parseFloat(row.querySelector('[data-type=start]').innerText),
                    end: parseFloat(row.querySelector('[data-type=end]').innerText),
                    text: row.querySelector('[data-type=text]').innerText
                });
            }
            return transcript;
        }
        // Handle trigger edit mode for row
        for (const tr of ui.segments_dom_table) {
            tr.addEventListener('dblclick', function() {
                tr.setAttribute('contenteditable', true);
                tr.focus();
            });
            tr.addEventListener('blur', function() {
                const save = confirm('Do you want to save changes ?');
                if (save) {
                    const actual_transcript = transcript_from_table();
                    post_transcript(actual_transcript).then(transcript => {
                        display_transcript(transcript);
                    });
                }
                tr.setAttribute('contenteditable', false);
            });
            // Handle keypresses during edit
            tr.addEventListener('keydown', function(e) {
                if (e.key == 'Escape') {
                    tr.blur();
                }
                if (e.key == 'Enter') {
                    tr.blur();
                }
            });
        }
    }

    // Setup timeline cursor dragging support
    function setup_timeline_cursor_drag() {
        let isDragging = false;
        let cursorOffsetX = 0;
        // Function to handle the start of dragging
        function startDragging(e) {
            e.preventDefault();
            isDragging = true;
            ui.transcript_timeline_cursor.style.cursor = 'grabbing';
        }
        // Function to handle the dragging
        function dragging(e) {
            if (isDragging) {
                const clientX = (e.clientX !== undefined) ? e.clientX : e.touches[0].clientX;
                // Calculate new position for cursor
                const timelineRect = ui.transcript_timeline.getBoundingClientRect();
                let newX = clientX - timelineRect.left;
                newX = Math.max(0, Math.min(newX, timelineRect.width)); // Clamp within timeline bounds
                // Update cursor position
                ui.transcript_timeline_cursor.style.left = newX + 'px';
                // Update player time in real-time
                const totalDuration = ui.transcript_timeline_totalduration;
                const newTime = (newX / timelineRect.width) * totalDuration;
                ui.player_time_dom.innerText = format_time(newTime);
                // Set player currentTime to the position of the cursor
                ui.player.currentTime = newTime;
            }
        }
        // Function to handle the end of dragging
        function stopDragging() {
            if (isDragging) {
                isDragging = false;
                ui.transcript_timeline_cursor.style.cursor = 'grab';
            }
        }
        // Mouse events
        ui.transcript_timeline_cursor.addEventListener('mouseover', () => {
            ui.transcript_timeline_cursor.style.cursor = 'grab';
        });
        ui.transcript_timeline_cursor.addEventListener('mouseout', () => {
            ui.transcript_timeline_cursor.style.cursor = 'default';
        });
        ui.transcript_timeline_cursor.addEventListener('mousedown', startDragging);
        document.addEventListener('mousemove', dragging);
        document.addEventListener('mouseup', stopDragging);  // FIXME: fails when mouseup on ui.player !        // Touch events
        ui.transcript_timeline.addEventListener('touchstart', startDragging);
        document.addEventListener('touchmove', dragging);
        document.addEventListener('touchend', stopDragging);
    }

    // Setup global keyboard shortcuts handling
    function setup_keyboard_shortcuts() {
        document.addEventListener('keydown', function(e) {
            const editing = document.querySelectorAll('[contenteditable=true]');
            if (editing.length) {  // Disable global shortcuts if editing
                return;
            }
            if (e.key == ' ') {
                e.preventDefault();
                if (ui.player.paused) ui.player.play();
                else ui.player.pause();
            }
            if (e.key == 'Home') {  // Skip to first segment
                play_skip_segment('first');
            }
            if (e.key == 'End') {  // Skip to last segment
                play_skip_segment('last');
            }
            if (e.key.startsWith('Arrow')) {
                if (e.key == 'ArrowRight') {  // Skip to next segment start time
                    play_skip_segment('next');
                }
                if (e.key == 'ArrowLeft') {  // Skip to previous segment start time
                    play_skip_segment('previous');
                }
            }
        });
    }

    // Skip player to previous/next segment
    function play_skip_segment(direction) {
        direction = direction || 'next';
        const currentTime = ui.player.currentTime;
        // Find next/previous segment
        let targetTime = null;
        let nearestSegment = null;
        if (direction === 'next') {
            for (const segment of ui.segments_sorted) {
                if (currentTime < segment.start) {
                    nearestSegment = segment;
                    break;
                }
            }
        }
        if (direction === 'previous') {
            for (let i = ui.segments_sorted.length - 1; i >= 0; i--) {
                const segment = ui.segments_sorted[i];
                if (currentTime > segment.start) {
                    nearestSegment = segment;
                    break;
                }
            }
        }
        if (direction === 'first') {
            nearestSegment = ui.segments_sorted[0];
        }
        if (direction === 'last') {
            nearestSegment = ui.segments_sorted[ui.segments_sorted.length - 1];
        }
        // Skip to segment start time (if applicable)
        if (nearestSegment) targetTime = nearestSegment.start;
        if (targetTime !== null) ui.player.currentTime = targetTime;
    }

    // Resize table and video to fit page height
    function adjustTableHeight() {
        const paddingBottom = 30;
        const viewportHeight = window.innerHeight;
        const viewportWidth = window.innerWidth;
        // Adjust video height, only when viewport is below lg breakpoint (992px)
        if (viewportWidth > 992) {
            console.log(viewportWidth)
            const videoTopPosition = ui.player.getBoundingClientRect().top;
            ui.player.style.maxHeight = (viewportHeight - videoTopPosition - paddingBottom) + 'px';
        } else {
            ui.player.style.maxHeight = '180px'; // Reset to default when above lg breakpoint
        }
        // Adjust transcript table height
        const tableTopPosition = ui.transcript_table.getBoundingClientRect().top;
        ui.transcript_table.style.overflow = 'scroll';
        ui.transcript_table.style.height = (viewportHeight - tableTopPosition - paddingBottom) + 'px';
    }
</script>

{% endblock %}
